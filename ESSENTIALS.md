# OAuth 2.0 の本質

## 1. 出発点：なぜブラウザでログインさせるのか

### 問題：パスワードを渡したくない

```
【悪い例】クライアントアプリにパスワードを入力
クライアントアプリ
    ↓
「GitHubのID・パスワードを入力してください」
    ↓
ユーザーがパスワードを入力
    ↓
クライアントアプリがパスワードを知ってしまう ❌
```

**危険：**
- クライアントアプリが悪意を持っていたら？
- パスワードを保存されたら？
- パスワードを他のサービスで試されたら？

### 解決：ブラウザで直接サービス側にログイン

```
【良い例】ブラウザ経由でサービス側のログイン画面へ
クライアントアプリ
    ↓
ブラウザを開く
    ↓
サービス側のログイン画面（GitHub.com）
    ↓
ユーザーがパスワードを入力
    ↓
クライアントアプリはパスワードを知らない ✅
```

**でも新しい問題が発生：**

---

## 2. 問題：ブラウザ経由だとトークンが露出する

### ブラウザ経由で直接トークンを返すと...

```
ユーザーがログイン（ブラウザ）
    ↓
サービス側が認証
    ↓ リダイレクト
/callback?access_token=abc123xyz  ← URLに表示
    ↓
ブラウザ履歴に残る ❌
リファラーで漏洩 ❌
ログに残る ❌
長期有効なトークンが露出 ❌
```

**ジレンマ：**
- パスワード保護のためにブラウザが必要
- でもブラウザ経由だとトークンが露出する

---

## 3. 解決：3つのトークンで役割分担

### トークンの露出度と有効期限

| トークン | 露出度 | 有効期限 | 使用回数 | 送り方 |
|---------|--------|---------|---------|--------|
| **認可コード** | **ブラウザに見える** | 10分 | 1回限り | URLパラメータ |
| **アクセストークン** | ブラウザに見えない | 1時間 | 何度でも | サーバー間通信 |
| **リフレッシュトークン** | ブラウザに見えない | 30-90日 | 何度でも | サーバー間通信 |

### 役割分担の考え方

```
認可コード:
  → ブラウザを安全に通過するための短期引換券
  → 盗まれても10分で無効 + 1回限り + client_secret が必要

アクセストークン:
  → API呼び出し用（頻繁にローテーション）
  → ブラウザに見えない場所で保管

リフレッシュトークン:
  → 長期セッション維持
  → ブラウザに見えない場所で保管
```

---

## 4. だから手続きはこうなる

### 2段階フロー

```
【フェーズ1】フロントチャネル（ブラウザ経由）
目的: パスワード保護 + 認可コード取得

クライアント → ブラウザ起動 → GET /authorize
    ↓
サービス側のログイン画面
    ↓
ユーザーがパスワード入力（クライアントには見えない）✅
    ↓
POST /authorize/consent
    ↓
認可コード発行（10分・使い捨て）
    ↓ リダイレクト
/callback?code=xyz  ← ブラウザに見えるが短命 ✅

----- ここでチャネルが切り替わる -----

【フェーズ2】バックチャネル（サーバー間通信）
目的: アクセストークン取得（ブラウザに見えない）

クライアント → POST /token
    code=xyz + client_secret
    ↓
サービス側が検証:
  - 認可コードが有効か
  - client_secret が正しいか
    ↓
アクセストークン発行
    ↓
クライアントが受け取り（ブラウザに見えない）✅
```

### フロー全体

```
T=0秒   GET /authorize → ログイン画面表示
T=30秒  POST /authorize/consent → 認可コード発行（10分）
        → /callback?code=xyz

T=31秒  POST /token（code + client_secret）
        → アクセストークン発行（1時間）
        ※ブラウザに見えない ✅

T=1分   GET /api/me
        Authorization: Bearer {access_token}
```

---

## 5. 認可コードの保護機構

### なぜ短命（10分）？

```
ブラウザ履歴に残る → でも10分で無効化 → 被害最小化
```

### なぜ使い捨て？

```
1回使ったら削除 → 盗まれて2回使われることを防ぐ
```

### なぜ client_secret が必要？

```
認可コードを盗まれた
    ↓ でも
client_secret を知らない
    ↓ だから
POST /token で弾かれる ✅
```

---

## 6. リフレッシュトークンの必要性

### なぜ認可コードを長期化しないのか

```
【悪い例】認可コードを30日有効にする
/callback?code=xyz  ← 30日有効
    ↓
ブラウザ履歴に30日間有効なトークンが残る ❌
```

### だからリフレッシュトークンを使う

```
【良い例】
/callback?code=xyz  ← 10分だけ有効
    ↓
POST /token
  → access_token（1時間）+ refresh_token（30日）
    ↓
サーバー側に保存（ブラウザに見えない）✅

1時間後:
  POST /token（refresh_token で自動更新）
    ↓ ブラウザには一切見えない ✅
```

---

## 7. フロントチャネル vs バックチャネル

| | フロントチャネル | バックチャネル |
|---|---|---|
| **経路** | ブラウザ経由 | サーバー間直接通信 |
| **送り方** | URLパラメータ | POSTボディ |
| **露出** | ブラウザに見える | ブラウザに見えない |
| **送るもの** | 認可コード | client_secret + 認可コード |
| **受け取るもの** | 認可コード | アクセストークン |
| **危険度** | 高い | 低い |

**役割分担：**
- フロントチャネル：パスワード保護 + 短命引換券の受け渡し
- バックチャネル：本物のトークン取得

---

## まとめ：設計の因果関係

```
1. パスワードを守りたい
     ↓ だから
   ブラウザでサービス側にログイン

2. でもブラウザ経由だとトークンが露出する
     ↓ だから
   短命・使い捨ての認可コードを経由

3. 認可コードだけでは不十分
     ↓ だから
   client_secret で保護

4. アクセストークンはブラウザに見せない
     ↓ だから
   サーバー間通信で取得

5. 長期セッションを維持したい
     ↓ でも
   認可コードを長期化できない（ブラウザ露出）
     ↓ だから
   リフレッシュトークン（ブラウザに見えない場所で保管）
```

**全ての設計は「パスワード保護」と「ブラウザ露出問題」から導かれる** ✅
